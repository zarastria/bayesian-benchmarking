---
title: "Benchmarking Model 2"
author: "Allen Baumgardner-Zuzik"
date: "February 1, 2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Performas a Bayesian calculation with uninformed priors to estimate model 2 of <paper>

$$ Y_{icb2} = \alpha_{b} + \delta^{T} T_{c} + \delta^{GK} T^{GK}_c + \beta X_{icb1} + \rho Y_{icb1} +\gamma_{1} \tau_{c} +\epsilon_{icb2} $$

### Warning

## Setup

### the needful

Load the relevant packages

```{r, include=FALSE, echo=FALSE}
library(tidyverse)
library(parallel)
library(cmdstanr)
library(brms)
library(rstan)
library(posterior)
#library(magrittr)
library(knitr)
library(broom)
library(broom.mixed)
library(tidybayes)
library(bayesplot)
library(bayestestR)
library(kableExtra)
library(xtable)
library(sjPlot)
#library(texreg)
library(tidymodels)
library(estimatr)
library(Hmisc)
library(vip)
library(car)
library(sandwich)
```

Set global core settings, if applicable. Use global setting only if necessary, best to use as an inline setting to avoid over allocating system resources
```{r, include=FALSE}
# # parallel package is needed for eh detectCores() and mclapply() function
# numCores <- detectCores()
# mc.cores = numCores 
```


### build the main dataset

Load the datasets

```{r, include=FALSE, echo=FALSE}
gik_hh_data <- as_tibble(read_csv("gik_household_panel.csv"))
# gik_ind_data <- as_tibble(read_csv("gik_ind_panel.csv"))
```

Merge into main dataset with intervention costs. The variables of interest are:

* `cost_per_beneficiary` - Cost per beneficiary to USAID in USD
* `overhead_cost_fraction` - Fraction of cost that is overhead
* `value_received` - Value received by beneficiary households in USD
* `spending_not_averted_fraction` - Fraction spending not averted if household not treated
* `cost_per_household` - Cost to USAID per eligible household
* `cost_per_village_household` - Cost to USAID per household in village

Merge into main dataset withcompliance rates. The variables of interest are as follows:

* `compliance_rate` - Compliance Rate among eligables
* `compliance_rate_population` - Compliance rate in population

```{r, include=FALSE, echo=FALSE}
gik_hh_main <- gik_hh_data %>%
  left_join(as_tibble(read_csv("intervention_costs.csv"))) %>%
  filter(eligible == "eligible", round == 2) %>%
  mutate(cost_deviation = (cost_per_beneficiary - 141.84)) %>% # create the cost-benefit differential per beneficary variable
  mutate(cost_deviation = replace_na(cost_deviation, 0)) %>%
  write_csv("gik_hh_main.csv")

# # The code below was used for validation purposes and is no longer applicable
# check <- gik_hh_main %>%
#   select(hhid, round, vid, m0_district, block, eligible, samp_wgt, 
#          treat_any, gd_treat, treatment, treat_GK, treated_GK, treat_GD_huge, treat_GD_main,
#          transferamount, cost_per_household, cost_per_beneficiary, value_received) %>%
#   filter(eligible == "eligible", round == 2) %>%
#   mutate(cost_deviation = (cost_per_beneficiary - 141.84)) %>% # create the cost-benefit differential per beneficary variable
#   mutate(cost_deviation = replace_na(cost_deviation, 0))
# 
# check %>%
#   summarise(itt_sum = sum(treat_GK, na.rm=TRUE), t_sum = sum(treated_GK),
#             itt_mean = mean(treat_GK, na.rm=TRUE), t_mean = mean(treated_GK))
# 
# view(check)
```

## The models - table 2

These models build out table 2 which presents the results for the primary and secondary outcomes utilizing uninformed priors utiling default brm values.

### **Per Capita Monthly Consumption** - Primary Outcome

Load the Monthly per capita consumption model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
per_cap_consumption_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         consumption_asinh, # Outcome variable
         consumption_asinh_R1, # Baseline value of consumption_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio) # controls
# view(per_cap_consumption_data)
```


**per capita consumption**: This is the basic bechmarking model utilzing the default, uninformed priors

```{r, include=FALSE, echo=FALSE}
per_cap_consumption_Bayesmodel <-
  brm(formula = consumption_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        consumption_asinh_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio +
        (1 | block) + (1 | vid),
     data = per_cap_consumption_data,
     family = gaussian("identity"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "uninformed_prior_outcomes\\per_cap_consumption_Bayes")
```

```{r, include=FALSE, echo=FALSE}
tidy_per_cap_consumption_Bayesmodel <- tidy(per_cap_consumption_Bayesmodel)
#view(tidy_per_cap_consumption_Bayesmodel)
write_csv(tidy_per_cap_consumption_Bayesmodel, "uninformed_prior_outcomes\\per_cap_consumption_bayes.csv")
```

Model Summery
```{r}
summary(per_cap_consumption_Bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(per_cap_consumption_Bayesmodel)
check_prior(per_cap_consumption_Bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(per_cap_consumption_Bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_consumption_asinh_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\per_cap_consumption_trace.png", plot = last_plot(), width = 12, height = 5)


#density diagnostic plot
mcmc_dens(per_cap_consumption_Bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_consumption_asinh_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\per_cap_consumption_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(per_cap_consumption_Bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_consumption_asinh_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\per_cap_consumption_overlay.png", plot = last_plot(), width = 12, height = 5)


#acf (auto-correlation) diagnostic plot
mcmc_acf(per_cap_consumption_Bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_consumption_asinh_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\per_cap_consumption_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(per_cap_consumption_Bayesmodel, nsamples = 100)
pp_check(per_cap_consumption_Bayesmodel, nsamples = 10, type = 'error_scatter_avg', alpha = .1)
```



### **Dietary Diversity** - Primary Outcome

Load the **Dietary Diversity** variables

```{r, include=FALSE}
dietary_diversity_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         dietarydiversity, # Outcome variable - Household dietary diversity score
         dietarydiversity_R1, # Baseline value of dietarydiversity, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, Lsavingsstock_asinh3, # controls
         Lconsumpti_x_Ldietarydi, Lconsumpti_x_Lproductiv, Ldietarydi_x_Lassetscon) # control interactions
```

**Dietary Diversity:** This is the basic bechmarking model utilizing the default, uninformed priors

```{r}
dietary_diversity_Bayesmodel <- 
  brm(formula = dietarydiversity | weights(samp_wgt) ~ 
        cost_deviation + treat_any + treat_GK + 
        dietarydiversity_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio + Lsavingsstock_asinh3 + 
        Lconsumpti_x_Ldietarydi + Lconsumpti_x_Lproductiv + Ldietarydi_x_Lassetscon + 
        (1 | vid) + (1 | block),
     data = dietary_diversity_data,
     family = gaussian("identity"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "uninformed_prior_outcomes\\dietary_diversity_Bayes")
```

```{r}
tidy_dietary_diversity_Bayesmodel <- tidy(dietary_diversity_Bayesmodel)
#view(tidy_dietary_diversity_Bayesmodel)
write_csv(tidy_dietary_diversity_Bayesmodel, "uninformed_prior_outcomes\\dietary_diversity_bayes.csv")
```

Model Summary
```{r}
summary(dietary_diversity_Bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(dietary_diversity_Bayesmodel)
check_prior(dietary_diversity_Bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(dietary_diversity_Bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_dietarydiversity_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "b_Lsavingsstock_asinh3",
                    "b_Lconsumpti_x_Ldietarydi", "b_Lconsumpti_x_Lproductiv", 
                    "b_Ldietarydi_x_Lassetscon", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\dietary_div_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plot
mcmc_dens(dietary_diversity_Bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_dietarydiversity_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "b_Lsavingsstock_asinh3",
                    "b_Lconsumpti_x_Ldietarydi", "b_Lconsumpti_x_Lproductiv", 
                    "b_Ldietarydi_x_Lassetscon", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\dietary_div_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(dietary_diversity_Bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_dietarydiversity_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "b_Lsavingsstock_asinh3",
                    "b_Lconsumpti_x_Ldietarydi", "b_Lconsumpti_x_Lproductiv", 
                    "b_Ldietarydi_x_Lassetscon", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\dietary_div_overlay.png", plot = last_plot(), width = 12, height = 5)


#acf (auto-correlation) diagnostic plot
mcmc_acf(dietary_diversity_Bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_dietarydiversity_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "b_Lsavingsstock_asinh3",
                    "b_Lconsumpti_x_Ldietarydi", "b_Lconsumpti_x_Lproductiv", 
                    "b_Ldietarydi_x_Lassetscon", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\dietary_div_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(dietary_diversity_Bayesmodel, nsamples = 100)
pp_check(dietary_diversity_Bayesmodel, nsamples = 10, type = 'error_scatter_avg', alpha = .1)
```



### **Total Household Wealth** - Primary Outcome

Load the **total household wealth** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
hh_wealth_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         wealth_asinh, # Outcome variable
         wealth_asinh_R1, # Baseline value of wealth_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, Lowndwelling) # controls
# view(per_cap_consumption_data)
```


**total household wealth**: This is the basic bechmarking model utilizing `brm()` default, uninformed priors

```{r}
hh_wealth_Bayesmodel <-
  brm(formula = wealth_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        wealth_asinh_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio + Lowndwelling +
        (1 | block) + (1 | vid),
     data = hh_wealth_data,
     family = gaussian("identity"),
     seed = 1272022,
     warmup = 4000,
     iter = 6000,
     thin = 2,
     control = list(adapt_delta = .99, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "uninformed_prior_outcomes\\hh_wealth_Bayes")
```

```{r, include=FALSE, echo=FALSE}
tidy_hh_wealth_Bayesmodel <- tidy(hh_wealth_Bayesmodel)
#view(tidy_hh_wealth_Bayesmodel)
write_csv(tidy_hh_wealth_Bayesmodel, "uninformed_prior_outcomes\\hh_wealth_Bayesmodel.csv")
```

Model Summery
```{r}
summary(hh_wealth_Bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(hh_wealth_Bayesmodel)
check_prior(hh_wealth_Bayesmodel)
```


```{r, include=FALSE, echo=FALSE}
## to be included in Table 3

# df_1 <- posterior_summary(hh_wealth_Bayesmodel)
# df_2 <- prior_summary(hh_wealth_Bayesmodel)
# df_3 <- check_prior(hh_wealth_Bayesmodel)
# 
# view(df_1)
# view(df_2)
# view(df_3)
# 
# draws <- as_draws_array(hh_wealth_Bayesmodel)
# view(draws)
# summarise_draws(draws, default_summary_measures())
# summarise_draws(draws, default_summary_measures())
# 
# order_draws <- order_draws(draws)
```


Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(hh_wealth_Bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_wealth_asinh_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "b_Lowndwelling",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\hh_wealth_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plot
mcmc_dens(hh_wealth_Bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_wealth_asinh_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "b_Lowndwelling",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\hh_wealth_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(hh_wealth_Bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_wealth_asinh_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "b_Lowndwelling",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\hh_wealth_dens_overlay.png", plot = last_plot(), width = 12, height = 5)


#acf (auto-correlation) diagnostic plot
mcmc_acf(hh_wealth_Bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_wealth_asinh_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "b_Lowndwelling",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\hh_wealth_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(hh_wealth_Bayesmodel, nsamples = 100)
pp_check(hh_wealth_Bayesmodel, nsamples = 10, type = 'error_scatter_avg', alpha = .1)
```


### **Borrowing Stock** - Secondary Outcome

Load the **borrowing stock** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
borrowing_stock_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         borrowingstock_asinh, # Outcome variable
         borrowingstock_asinh_R1, # Baseline value of borrowingstock_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio) # controls
```


**borrowing stock**: This is the basic bechmarking model utilizing `brm()` default, uninformed priors

```{r}
borrowing_stock_bayesmodel <-
  brm(formula = borrowingstock_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        borrowingstock_asinh_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio +
        (1 | block) + (1 | vid),
     data = borrowing_stock_data,
     family = gaussian("identity"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "uninformed_prior_outcomes\\borrowing_stock_bayes")
```

```{r, include=FALSE, echo=FALSE}
tidy_borrowing_stock_bayesmodel <- tidy(borrowing_stock_bayesmodel)
write_csv(tidy_borrowing_stock_bayesmodel, "uninformed_prior_outcomes\\borrowing_stock_bayes.csv")
```

Model Summery
```{r}
summary(borrowing_stock_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(borrowing_stock_bayesmodel)
check_prior(borrowing_stock_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(borrowing_stock_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_borrowingstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\borrowing_stock_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(borrowing_stock_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_borrowingstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\borrowing_stock_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(borrowing_stock_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_borrowingstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\borrowing_stock_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(borrowing_stock_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_borrowingstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\borrowing_stock_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(borrowing_stock_bayesmodel, nsamples = 100)
pp_check(borrowing_stock_bayesmodel, nsamples = 10, type = 'error_scatter_avg', alpha = .1)
```


### **Savings Stock** - Secondary Outcome

Load the **savings stock** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
savings_stock_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         savingsstock_asinh, # Outcome variable
         savingsstock_asinh_R1, # Baseline value of savingsstock_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, # controls
         Lconsumpti_x_Lproductiv, Lconsumpti_x_Lassetscon) # interactions
# view(per_cap_consumption_data)
```


**savings stock**: This is the basic bechmarking model utilzing `brm()` default uninformed priors

```{r}
savings_stock_bayesmodel <-
  brm(formula = savingsstock_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        savingsstock_asinh_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio + 
        Lconsumpti_x_Lproductiv + Lconsumpti_x_Lassetscon +
        (1 | block) + (1 | vid),
     data = savings_stock_data,
     family = gaussian("identity"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "uninformed_prior_outcomes\\savings_stock_bayes")
```

```{r, include=FALSE, echo=FALSE}
tidy_savings_stock_bayesmodel <- tidy(savings_stock_bayesmodel)
#view(tidy_savings_stock_bayesmodel)
write_csv(tidy_savings_stock_bayesmodel, "uninformed_prior_outcomes\\savings_stock_bayes.csv")
```

Model Summery
```{r}
summary(savings_stock_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(savings_stock_bayesmodel)
check_prior(savings_stock_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(savings_stock_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_savingsstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lproductiv", "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\savings_stock_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(savings_stock_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_savingsstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lproductiv", "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\savings_stock_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(savings_stock_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_savingsstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lproductiv", "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\savings_stock_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(savings_stock_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_savingsstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lproductiv", "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\savings_stock_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(savings_stock_bayesmodel, nsamples = 100)
pp_check(savings_stock_bayesmodel, nsamples = 10, type = 'error_scatter_avg', alpha = .1)
```


### **Health Knowledge** - Secondary Outcome

Load the **health knowledge** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
health_knowledge_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         health_knowledge, # Outcome variable
         health_knowledge_R1, # Baseline value of health_knowledge, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio) # controls
```


**health knowledge**: This is the basic bechmarking model utilzing `brm()` default, uninformed priors

```{r}
health_knowledge_bayesmodel <-
  brm(formula = health_knowledge | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        health_knowledge_R1 + 
        Lhh_wealth_asinh + Lvill_eligible_ratio +
        (1 | block) + (1 | vid),
     data = health_knowledge_data,
     family = gaussian("identity"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "uninformed_prior_outcomes\\health_knowledge_bayes")
```

```{r, include=FALSE, echo=FALSE}
tidy_health_knowledge_bayesmodel <- tidy(health_knowledge_bayesmodel)
#view(tidy_health_knowledge_bayesmodel)
write_csv(tidy_health_knowledge_bayesmodel, "uninformed_prior_outcomes\\health_knowledge_bayes.csv")
```

Model Summery
```{r}
summary(health_knowledge_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(health_knowledge_bayesmodel)
check_prior(health_knowledge_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(health_knowledge_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_health_knowledge_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\health_knowledge_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(health_knowledge_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_health_knowledge_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\health_knowledge_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(health_knowledge_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_health_knowledge_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\health_knowledge_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(health_knowledge_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_health_knowledge_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\health_knowledge_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(health_knowledge_bayesmodel, ndraws = 100)
pp_check(health_knowledge_bayesmodel, ndraws = 10, type = 'error_scatter_avg', alpha = .1)
```


### **sanitation practices** - Secondary Outcome

Load the **sanitation practices** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
sanitation_practices_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         sanitation_practices, # Outcome variable
         sanitation_practices_R1, # Baseline value of sanitation_practices, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, # controls
         Lproductiv_x_Lassetscon) # Interactions
```


**sanitation practices**: This is the basic benchmarking model utilizing the default, uninformed priors

```{r}
sanitation_practices_bayesmodel <-
  brm(formula = sanitation_practices | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        sanitation_practices_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio +
        Lproductiv_x_Lassetscon +
        (1 | block) + (1 | vid),
     data = sanitation_practices_data,
     family = gaussian("identity"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "uninformed_prior_outcomes\\sanitation_practices_bayes")
```

```{r, include=FALSE, echo=FALSE}
tidy_sanitation_practices_bayesmodel <- tidy(sanitation_practices_bayesmodel)
#view(tidy_sanitation_practices_bayesmodel)
write_csv(tidy_sanitation_practices_bayesmodel, "uninformed_prior_outcomes\\sanitation_practices_bayes.csv")
```

Model Summery
```{r}
summary(sanitation_practices_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(sanitation_practices_bayesmodel)
check_prior(sanitation_practices_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(sanitation_practices_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_sanitation_practices_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\sanitation_practices_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(sanitation_practices_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_sanitation_practices_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\sanitation_practices_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(sanitation_practices_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_sanitation_practices_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\sanitation_practices_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(sanitation_practices_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_sanitation_practices_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\sanitation_practices_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(sanitation_practices_bayesmodel, ndraws = 100)
pp_check(sanitation_practices_bayesmodel, ndraws = 10, type = 'error_scatter_avg', alpha = .1)
```


### **productive assets** - Secondary Outcome

Load the **productive assets** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
productive_assets_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         productiveassets_asinh, # Outcome variable
         productiveassets_asinh_R1, # Baseline value of productiveassets_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, # controls
         Lconsumpti_x_Lassetscon) # Interactions
# view(per_cap_consumption_data)
```


**productive assets**: This is the basic benchmarking model utilizing the default, uninformed priors

```{r}
productive_assets_bayesmodel <-
  brm(formula = productiveassets_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        productiveassets_asinh_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio +
        Lconsumpti_x_Lassetscon +
        (1 | block) + (1 | vid),
     data = productive_assets_data,
     family = gaussian("identity"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "uninformed_prior_outcomes\\productive_assets_bayes")
```

```{r, include=FALSE, echo=FALSE}
tidy_productive_assets_bayesmodel <- tidy(productive_assets_bayesmodel)
#view(tidy_productive_assets_bayesmodel)
write_csv(tidy_productive_assets_bayesmodel, "uninformed_prior_outcomes\\productive_assets_bayes.csv")
```

Model Summery
```{r}
summary(productive_assets_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(productive_assets_bayesmodel)
check_prior(productive_assets_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(productive_assets_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_productiveassets_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\productive_assets_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(productive_assets_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_productiveassets_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\productive_assets_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(productive_assets_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_productiveassets_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\productive_assets_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(productive_assets_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_productiveassets_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\productive_assets_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(productive_assets_bayesmodel, ndraws = 100)
pp_check(productive_assets_bayesmodel, ndraws = 10, type = 'error_scatter_avg', alpha = .1)
```


### **Consumption Assets** - Secondary Outcome

Load the **consumption assets** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
consumption_assets_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         assetsconsumption_asinh, # Outcome variable
         assetsconsumption_asinh_R1, # Baseline value of assetsconsumption_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, Lroomsnumb, Ldurablesexpenditure,  # controls
         Ldietarydi_x_Lassetscon, Lproductiv_x_Lassetscon) # Interactions
```

**consumption assets**: This is the basic benchmarking model utilizing the default, uninformed priors

```{r}
consumption_assets_bayesmodel <-
  brm(formula = assetsconsumption_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        assetsconsumption_asinh_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio + Lroomsnumb + Ldurablesexpenditure +
        Ldietarydi_x_Lassetscon + Lproductiv_x_Lassetscon +
        (1 | block) + (1 | vid),
     data = consumption_assets_data,
     family = gaussian("identity"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "uninformed_prior_outcomes\\consumption_assets_bayes")
```

```{r, include=FALSE, echo=FALSE}
tidy_consumption_assets_bayesmodel <- tidy(consumption_assets_bayesmodel)
#view(tidy_consumption_assets_bayesmodel)
write_csv(tidy_consumption_assets_bayesmodel, "uninformed_prior_outcomes\\consumption_assets_bayes.csv")
```

Model Summery
```{r}
summary(consumption_assets_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(consumption_assets_bayesmodel)
check_prior(consumption_assets_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(consumption_assets_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_assetsconsumption_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "b_Ldietarydi_x_Lassetscon", "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\consumption_assets_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(consumption_assets_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_assetsconsumption_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "b_Ldietarydi_x_Lassetscon", "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\consumption_assets_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(consumption_assets_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_assetsconsumption_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "b_Ldietarydi_x_Lassetscon", "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\consumption_assets_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(consumption_assets_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_assetsconsumption_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "b_Ldietarydi_x_Lassetscon", "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\consumption_assets_assets_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(consumption_assets_bayesmodel, ndraws = 100)
pp_check(consumption_assets_bayesmodel, ndraws = 10, type = 'error_scatter_avg', alpha = .1)
```


### **House Value** - Secondary Outcome

Load the **house value** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
dwelling_cost_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         selfcostdwell_asinh, # Outcome variable
         selfcostdwell_asinh_R1, # Baseline value of selfcostdwell_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, Lroomsnumb, Ldurablesexpenditure)  # controls
```


**house value**: This is the basic benchmarking model utilizing the default, uninformed priors

```{r}
dwelling_cost_bayesmodel <-
  brm(formula = selfcostdwell_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        selfcostdwell_asinh_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio + Lroomsnumb + Ldurablesexpenditure +
        (1 | block) + (1 | vid),
     data = dwelling_cost_data,
     family = gaussian("identity"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "uninformed_prior_outcomes\\dwelling_cost_bayes")
```

```{r, include=FALSE, echo=FALSE}
tidy_dwelling_cost_bayesmodel <- tidy(dwelling_cost_bayesmodel)
#view(tidy_dwelling_cost_bayesmodel)
write_csv(tidy_dwelling_cost_bayesmodel, "uninformed_prior_outcomes\\dwelling_cost_bayes.csv")
```

Model Summery
```{r}
summary(dwelling_cost_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(dwelling_cost_bayesmodel)
check_prior(dwelling_cost_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(dwelling_cost_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_selfcostdwell_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\dwelling_cost_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(dwelling_cost_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_selfcostdwell_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\dwelling_cost_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(dwelling_cost_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_selfcostdwell_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\dwelling_cost_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(dwelling_cost_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_selfcostdwell_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\dwelling_cost_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(dwelling_cost_bayesmodel, ndraws = 100)
pp_check(dwelling_cost_bayesmodel, ndraws = 10, type = 'error_scatter_avg', alpha = .1)
```


### **house quality** - Secondary Outcome

Load the **house quality** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
housing_quality_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         housing_quality, # Outcome variable
         housing_quality_R1, # Baseline value of housing_quality, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, Lroomsnumb)  # controls
```


**house quality**: This is the basic benchmarking model utilizing the default, uninformed priors

```{r}
housing_quality_bayesmodel <-
  brm(formula = housing_quality | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        housing_quality_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio + Lroomsnumb +
        (1 | block) + (1 | vid),
     data = housing_quality_data,
     family = gaussian("identity"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "uninformed_prior_outcomes\\housing_quality_bayes")
```

```{r, include=FALSE, echo=FALSE}
tidy_housing_quality_bayesmodel <- tidy(housing_quality_bayesmodel)
#view(tidy_housing_quality_bayesmodel)
write_csv(tidy_housing_quality_bayesmodel, "uninformed_prior_outcomes\\housing_quality_bayes.csv")
```

Model Summery
```{r}
summary(housing_quality_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(housing_quality_bayesmodel)
check_prior(housing_quality_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(housing_quality_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_housing_quality_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", "b_Lroomsnumb",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\housing_quality_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(housing_quality_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_housing_quality_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", "b_Lroomsnumb",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\housing_quality_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(housing_quality_bayesmodel,
           pars = c("b_Intercept", "b_
                    
                    cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_housing_quality_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", "b_Lroomsnumb",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\housing_quality_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(housing_quality_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_housing_quality_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", "b_Lroomsnumb",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_2_diagnostics\\housing_quality_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(housing_quality_bayesmodel, ndraws = 100)
pp_check(housing_quality_bayesmodel, ndraws = 10, type = 'error_scatter_avg', alpha = .1)
```




