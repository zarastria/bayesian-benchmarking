---
title: "Benchmarking Models 3 - Informed Priors"
Author: "Allen Baumgardner-Zuzik"
date: 'March 18, 2022'
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Performs a Bayesian calculation with uninformed priors to estimate model 2 of <paper>

$$ Y_{icb2} = \alpha_{b} + \delta^{T} T_{c} + \delta^{GK} T^{GK}_c + \beta X_{icb1} + \rho Y_{icb1} +\gamma_{1} \tau_{c} +\epsilon_{icb2} $$

### Warnings (if applicable)

## Setup

### the needful

Load the relevant packages

```{r, include=FALSE, echo=FALSE}
library(tidyverse)
library(parallel)
library(cmdstanr)
library(brms)
library(rstan)
library(posterior)
#library(magrittr)
library(knitr)
library(broom)
library(broom.mixed)
library(tidybayes)
library(bayesplot)
library(bayestestR)
library(kableExtra)
library(xtable)
library(sjPlot)
#library(texreg)
library(tidymodels)
library(estimatr)
library(Hmisc)
library(vip)
library(car)
library(sandwich)
```

Set global core settings, if applicable. Use global setting only if necessary, best to use as an inline setting to avoid over allocating system resources

```{r, include=FALSE}
# # parallel package is needed for eh detectCores() and mclapply() function
# numCores <- detectCores()
# mc.cores = numCores 
```


## The models - table 3

These models build out table 3 which presents the results for the primary and secondary outcomes utilizing informed priors with 1. normal distributions and 2. Cauchy distributions.We follow the advice of Rachael Meager and incorporate disagreement in the literature and use 6 standard deviations and a mean = 0

### **Per Capita Monthly Consumption** - Primary Outcome
 
Load the Monthly per capita consumption model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
per_cap_consumption_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         consumption_asinh, # Outcome variable
         consumption_asinh_R1, # Baseline value of consumption_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio) # controls
# view(per_cap_consumption_data)
```

#### *Normal Distribution* 

**per capita consumption**: This is the basic benchmarking model utilizing the a global normal distribution with mean = 0 and 6 standard deviations.

```{r, include=FALSE, echo=FALSE}
per_cap_consumption_normal_bayesmodel <-
  brm(formula = consumption_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        consumption_asinh_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio +
        (1 | block) + (1 | vid),
     data = per_cap_consumption_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"), 
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\per_cap_consumption_normal_bayes")
```


```{r, include=FALSE, echo=FALSE}
# tidy_per_cap_consumption_Bayesmodel <- tidy(per_cap_consumption_Bayesmodel)
# #view(tidy_per_cap_consumption_Bayesmodel)
# write_csv(tidy_per_cap_consumption_Bayesmodel, "uninformed_prior_outcomes\\per_cap_consumption_normal_bayes.csv")
```

Model Summery
```{r}
summary(per_cap_consumption_normal_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(per_cap_consumption_normal_bayesmodel)
check_prior(per_cap_consumption_normal_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(per_cap_consumption_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_consumption_asinh_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\per_cap_consumption_norm_trace.png", plot = last_plot(), width = 12, height = 5)


#density diagnostic plot
mcmc_dens(per_cap_consumption_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_consumption_asinh_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\per_cap_consumption_norm_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(per_cap_consumption_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_consumption_asinh_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\per_cap_consumption_norm_overlay.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens(per_cap_consumption_normal_bayesmodel,pars = c("b_treat_GK"))
mcmc_dens_overlay(per_cap_consumption_normal_bayesmodel,pars = c("b_treat_GK"))


#acf (auto-correlation) diagnostic plot
mcmc_acf(per_cap_consumption_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_consumption_asinh_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\per_cap_consumption_norm_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(per_cap_consumption_normal_bayesmodel, nsamples = 100)
pp_check(per_cap_consumption_normal_bayesmodel, nsamples = 10, type = 'error_scatter_avg', alpha = .1)
```


### **Dietary Diversity** - Primary Outcome

Load the **Dietary Diversity** variables

```{r, include=FALSE}
dietary_diversity_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         dietarydiversity, # Outcome variable - Household dietary diversity score
         dietarydiversity_R1, # Baseline value of dietarydiversity, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, Lsavingsstock_asinh3, # controls
         Lconsumpti_x_Ldietarydi, Lconsumpti_x_Lproductiv, Ldietarydi_x_Lassetscon) # control interactions
```

**Dietary Diversity:** This is the basic bechmarking model utilizing the default, uninformed priors

```{r}
dietary_diversity_normal_bayesmodel <- 
  brm(formula = dietarydiversity | weights(samp_wgt) ~ 
        cost_deviation + treat_any + treat_GK + 
        dietarydiversity_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio + Lsavingsstock_asinh3 + 
        Lconsumpti_x_Ldietarydi + Lconsumpti_x_Lproductiv + Ldietarydi_x_Lassetscon + 
        (1 | vid) + (1 | block),
     data = dietary_diversity_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\dietary_diversity_normal_bayes")
```

```{r}
# tidy_dietary_diversity_normal_bayesmodel <- tidy(dietary_diversity_normal_bayesmodel)
# #view(tidy_dietary_diversity_normal_bayesmodel)
# write_csv(tidy_dietary_diversity_normal_bayesmodel, "informed_prior_outcomes\\dietary_diversity_normal_bayes.csv")
```

Model Summary
```{r}
summary(dietary_diversity_normal_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(dietary_diversity_normal_bayesmodel)
check_prior(dietary_diversity_normal_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(dietary_diversity_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_dietarydiversity_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "b_Lsavingsstock_asinh3",
                    "b_Lconsumpti_x_Ldietarydi", "b_Lconsumpti_x_Lproductiv", 
                    "b_Ldietarydi_x_Lassetscon", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\dietary_div_normal_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plot
mcmc_dens(dietary_diversity_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_dietarydiversity_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "b_Lsavingsstock_asinh3",
                    "b_Lconsumpti_x_Ldietarydi", "b_Lconsumpti_x_Lproductiv", 
                    "b_Ldietarydi_x_Lassetscon", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\dietary_div_normal_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(dietary_diversity_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_dietarydiversity_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "b_Lsavingsstock_asinh3",
                    "b_Lconsumpti_x_Ldietarydi", "b_Lconsumpti_x_Lproductiv", 
                    "b_Ldietarydi_x_Lassetscon", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\dietary_div_normal_overlay.png", plot = last_plot(), width = 12, height = 5)


#acf (auto-correlation) diagnostic plot
mcmc_acf(dietary_diversity_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_dietarydiversity_R1", "b_Lhh_wealth_asinh",
                    "b_Lvill_eligible_ratio", "b_Lsavingsstock_asinh3",
                    "b_Lconsumpti_x_Ldietarydi", "b_Lconsumpti_x_Lproductiv", 
                    "b_Ldietarydi_x_Lassetscon", "sd_block__Intercept", 
                    "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\dietary_div_normal_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(dietary_diversity_normal_bayesmodel, nsamples = 100)
pp_check(dietary_diversity_normal_bayesmodel, nsamples = 10, type = 'error_scatter_avg', alpha = .1)
```


### **Total Household Wealth** - Primary Outcome

Load the **total household wealth** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
hh_wealth_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         wealth_asinh, # Outcome variable
         wealth_asinh_R1, # Baseline value of wealth_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, Lowndwelling) # controls
# view(per_cap_consumption_data)
```


**total household wealth**: This is the basic benchmarking model utilizing `brm()` default, uninformed priors. Removed Lhh_wealth_asinh to account for collinearity issues.

```{r}
hh_wealth_normal_bayesmodel <-
  brm(formula = wealth_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        wealth_asinh_R1 + Lvill_eligible_ratio + Lowndwelling +
        (1 | block) + (1 | vid),
     data = hh_wealth_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .99, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\hh_wealth_normal_bayes")
```

```{r, include=FALSE, echo=FALSE}
# tidy_hh_wealth_normal_bayesmodel <- tidy(hh_wealth_normal_bayesmodel)
# #view(tidy_hh_wealth_normal_bayesmodel)
# write_csv(tidy_hh_wealth_normal_bayesmodel, "informed_prior_outcomes\\hh_wealth_normal_bayesmodel.csv")
```

Model Summery
```{r}
summary(hh_wealth_normal_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(hh_wealth_normal_bayesmodel)
check_prior(hh_wealth_normal_bayesmodel)
```


```{r, include=FALSE, echo=FALSE}
## to be included in Table 3

# df_1 <- posterior_summary(hh_wealth_Bayesmodel)
# df_2 <- prior_summary(hh_wealth_Bayesmodel)
# df_3 <- check_prior(hh_wealth_Bayesmodel)
# 
# view(df_1)
# view(df_2)
# view(df_3)
# 
# draws <- as_draws_array(hh_wealth_Bayesmodel)
# view(draws)
# summarise_draws(draws, default_summary_measures())
# summarise_draws(draws, default_summary_measures())
# 
# order_draws <- order_draws(draws)
```


Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(hh_wealth_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_wealth_asinh_R1",
                    "b_Lvill_eligible_ratio", "b_Lowndwelling",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\hh_wealth_normal_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plot
mcmc_dens(hh_wealth_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_wealth_asinh_R1",
                    "b_Lvill_eligible_ratio", "b_Lowndwelling",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\hh_wealth_normal_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(hh_wealth_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_wealth_asinh_R1",
                    "b_Lvill_eligible_ratio", "b_Lowndwelling",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\hh_wealth_normal_dens_overlay.png", plot = last_plot(), width = 12, height = 5)


#acf (auto-correlation) diagnostic plot
mcmc_acf(hh_wealth_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", 
                    "b_treat_GK", "b_wealth_asinh_R1",
                    "b_Lvill_eligible_ratio", "b_Lowndwelling",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\hh_wealth_normal_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(hh_wealth_normal_bayesmodel, nsamples = 100)
pp_check(hh_wealth_normal_bayesmodel, nsamples = 10, type = 'error_scatter_avg', alpha = .1)
```


### **Borrowing Stock** - Secondary Outcome

Load the **borrowing stock** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
borrowing_stock_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         borrowingstock_asinh, # Outcome variable
         borrowingstock_asinh_R1, # Baseline value of borrowingstock_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio) # controls
```


**borrowing stock**: This is the basic benchmarking model utilizing `brm()` global weakly informed priors with mean = 0 and 6 standard deviations.

```{r}
borrowing_stock_normal_bayesmodel <-
  brm(formula = borrowingstock_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        borrowingstock_asinh_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio +
        (1 | block) + (1 | vid),
     data = borrowing_stock_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\borrowing_stock_normal_bayes")
```

```{r, include=FALSE, echo=FALSE}
tidy_borrowing_stock_normal_bayesmodel <- tidy(borrowing_stock_normal_bayesmodel)
write_csv(tidy_borrowing_stock_normal_bayesmodel, "uninformed_prior_outcomes\\borrowing_stock_normal_bayes.csv")
```

Model Summery
```{r}
summary(borrowing_stock_normal_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(borrowing_stock_normal_bayesmodel)
check_prior(borrowing_stock_normal_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(borrowing_stock_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_borrowingstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\borrowing_stock_normal_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(borrowing_stock_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_borrowingstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\borrowing_stock_normal_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(borrowing_stock_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_borrowingstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\borrowing_stock_normal_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(borrowing_stock_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_borrowingstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\borrowing_stock_normal_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(borrowing_stock_normal_bayesmodel, nsamples = 100)
pp_check(borrowing_stock_normal_bayesmodel, nsamples = 10, type = 'error_scatter_avg', alpha = .1)
```


### **Savings Stock** - Secondary Outcome

Load the **savings stock** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
savings_stock_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         savingsstock_asinh, # Outcome variable
         savingsstock_asinh_R1, # Baseline value of savingsstock_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, # controls
         Lconsumpti_x_Lproductiv, Lconsumpti_x_Lassetscon) # interactions
# view(per_cap_consumption_data)
```


**savings stock**: This is the basic bechmarking model utilzing `brm()` default uninformed priors

```{r}
savings_stock_normal_bayesmodel <-
  brm(formula = savingsstock_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        savingsstock_asinh_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio + 
        Lconsumpti_x_Lproductiv + Lconsumpti_x_Lassetscon +
        (1 | block) + (1 | vid),
     data = savings_stock_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\savings_stock_normal_bayes")
```

```{r, include=FALSE, echo=FALSE}
# tidy_savings_stock_normal_bayesmodel <- tidy(savings_stock_normal_bayesmodel)
# #view(tidy_savings_stock_normal_bayesmodel)
# write_csv(tidy_savings_stock_normal_bayesmodel, "informed_prior_outcomes\\savings_stock_normal_bayes.csv")
```

Model Summery
```{r}
summary(savings_stock_normal_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(savings_stock_normal_bayesmodel)
check_prior(savings_stock_normal_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(savings_stock_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_savingsstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lproductiv", "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\savings_stock_normal_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(savings_stock_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_savingsstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lproductiv", "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\savings_stock_normal_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(savings_stock_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_savingsstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lproductiv", "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\savings_stock_normal_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(savings_stock_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_savingsstock_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lproductiv", "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\savings_stock_normal_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(savings_stock_normal_bayesmodel, nsamples = 100)
pp_check(savings_stock_normal_bayesmodel, nsamples = 10, type = 'error_scatter_avg', alpha = .1)
```


### **Health Knowledge** - Secondary Outcome

Load the **health knowledge** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
health_knowledge_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         health_knowledge, # Outcome variable
         health_knowledge_R1, # Baseline value of health_knowledge, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio) # controls
```


**health knowledge**: This is the basic bechmarking model utilzing `brm()` a normal distribution. Try to increase to 2000 and 3000 total iterations. Check block intercept.

```{r}
health_knowledge_normal_bayesmodel <-
  brm(formula = health_knowledge | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        health_knowledge_R1 + 
        Lhh_wealth_asinh + Lvill_eligible_ratio +
        (1 | block) + (1 | vid),
     data = health_knowledge_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"),
     seed = 1272022,
     warmup = 2000,
     iter = 3000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\health_knowledge_normal_bayes")
```

```{r, include=FALSE, echo=FALSE}
# tidy_health_knowledge_normal_bayesmodel <- tidy(health_knowledge_normal_bayesmodel)
# #view(tidy_health_knowledge_normal_bayesmodel)
# write_csv(tidy_health_knowledge_normal_bayesmodel, "informed_prior_outcomes\\health_knowledge_normal_bayes.csv")
```

Model Summery
```{r}
summary(health_knowledge_normal_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(health_knowledge_normal_bayesmodel)
check_prior(health_knowledge_normal_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(health_knowledge_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_health_knowledge_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\health_knowledge_normal_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(health_knowledge_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_health_knowledge_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\health_knowledge_normal_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(health_knowledge_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_health_knowledge_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\health_knowledge_normal_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(health_knowledge_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_health_knowledge_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\health_knowledge_normal_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(health_knowledge_normal_bayesmodel, ndraws = 100)
pp_check(health_knowledge_normal_bayesmodel, ndraws = 10, type = 'error_scatter_avg', alpha = .1)
```


### **sanitation practices** - Secondary Outcome

Load the **sanitation practices** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
sanitation_practices_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         sanitation_practices, # Outcome variable
         sanitation_practices_R1, # Baseline value of sanitation_practices, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, # controls
         Lproductiv_x_Lassetscon) # Interactions
```


**sanitation practices**: This is the basic benchmarking model utilizing the default, uninformed priors

```{r}
sanitation_practices_normal_bayesmodel <-
  brm(formula = sanitation_practices | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        sanitation_practices_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio +
        Lproductiv_x_Lassetscon +
        (1 | block) + (1 | vid),
     data = sanitation_practices_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\sanitation_practices_normal_bayes")
```

```{r, include=FALSE, echo=FALSE}
# tidy_sanitation_practices_normal_bayesmodel <- tidy(sanitation_practices_normal_bayesmodel)
# #view(tidy_sanitation_practices_normal_bayesmodel)
# write_csv(tidy_sanitation_practices_normal_bayesmodel, "informed_prior_outcomes\\sanitation_practices_normal_bayes.csv")
```

Model Summery
```{r}
summary(sanitation_practices_normal_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(sanitation_practices_normal_bayesmodel)
check_prior(sanitation_practices_normal_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(sanitation_practices_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_sanitation_practices_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\sanitation_practices_normal_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(sanitation_practices_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_sanitation_practices_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\sanitation_practices_normal_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(sanitation_practices_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_sanitation_practices_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\sanitation_practices_normal_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(sanitation_practices_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_sanitation_practices_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\sanitation_practices_normal_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(sanitation_practices_normal_bayesmodel, ndraws = 100)
pp_check(sanitation_practices_normal_bayesmodel, ndraws = 10, type = 'error_scatter_avg', alpha = .1)
```


### **productive assets** - Secondary Outcome

Load the **productive assets** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
productive_assets_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         productiveassets_asinh, # Outcome variable
         productiveassets_asinh_R1, # Baseline value of productiveassets_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, # controls
         Lconsumpti_x_Lassetscon) # Interactions
# view(per_cap_consumption_data)
```


**productive assets**: This is the basic benchmarking model utilizing the default, uninformed priors

```{r}
productive_assets_normal_bayesmodel <-
  brm(formula = productiveassets_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        productiveassets_asinh_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio +
        Lconsumpti_x_Lassetscon +
        (1 | block) + (1 | vid),
     data = productive_assets_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\productive_assets_normal_bayes")
```

```{r, include=FALSE, echo=FALSE}
tidy_productive_assets_normal_bayesmodel <- tidy(productive_assets_normal_bayesmodel)
#view(tidy_productive_assets_normal_bayesmodel)
write_csv(tidy_productive_assets_normal_bayesmodel, "informed_prior_outcomes\\productive_assets_normal_bayes.csv")
```

Model Summery
```{r}
summary(productive_assets_normal_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(productive_assets_normal_bayesmodel)
check_prior(productive_assets_normal_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(productive_assets_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_productiveassets_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\productive_assets_normal_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(productive_assets_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_productiveassets_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\productive_assets_normal_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(productive_assets_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_productiveassets_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\productive_assets_normal_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(productive_assets_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_productiveassets_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio",
                    "b_Lconsumpti_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\productive_assets_normal_cf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(productive_assets_normal_bayesmodel, ndraws = 100)
pp_check(productive_assets_normal_bayesmodel, ndraws = 10, type = 'error_scatter_avg', alpha = .1)
```


### **Consumption Assets** - Secondary Outcome

Load the **consumption assets** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
consumption_assets_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         assetsconsumption_asinh, # Outcome variable
         assetsconsumption_asinh_R1, # Baseline value of assetsconsumption_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, Lroomsnumb, Ldurablesexpenditure,  # controls
         Ldietarydi_x_Lassetscon, Lproductiv_x_Lassetscon) # Interactions
view(consumption_assets_data)


hist(consumption_assets_data$assetsconsumption_asinh)
```
create a dummie variable = 0 if assets consumption = 0 and 1 if assets consumption > 0. distinguishes between the two groups

**consumption assets**: This is the basic benchmarking model utilizing a global normal prior with mean =  and 6 standard deviations. This model has a number of errors. Try increasing burn in to 15,000. Also, run a correlation matrix to see which LASSO variables are causing problems. remove one variable at a time.
  
* Warning: There were 4 chains where the estimated Bayesian Fraction of Missing Information was low. See https://mc-stan.org/misc/warnings.html#bfmi-low
* Warning: Examine the pairs() plot to diagnose sampling problems
* Warning: The largest R-hat is 4.48, indicating chains have not mixed. Running the chains for more iterations may help. See https://mc-stan.org/misc/warnings.html#r-hat
* Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable.
* Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. https://mc-stan.org/misc/warnings.html#tail-ess

```{r}
consumption_assets_normal_bayesmodel <-
  brm(formula = assetsconsumption_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        assetsconsumption_asinh_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio + Lroomsnumb + Ldurablesexpenditure +
        Ldietarydi_x_Lassetscon + Lproductiv_x_Lassetscon +
        (1 | block) + (1 | vid),
     data = consumption_assets_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\consumption_assets_normal_bayes")
```

remove baseline and controls to see if the model stabilizes

```{r}
consumption_assets_normal_bayesmodel <-
  brm(formula = assetsconsumption_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        (1 | block) + (1 | vid),
     data = consumption_assets_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\consumption_assets_normal_bayes_v2")

# trace diagnostic plot
mcmc_trace(consumption_assets_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\consumption_assets_normal_race.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(consumption_assets_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\consumption_assets_normal_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(consumption_assets_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\consumption_assets_normal_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(consumption_assets_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))


```

correlation matrix
```{r}
cor_data <- consumption_assets_data %>%
  select(assetsconsumption_asinh, cost_deviation, treat_any, treat_GK, Lhh_wealth_asinh,
         Lvill_eligible_ratio, Lroomsnumb, Ldurablesexpenditure, block, vid)
cor(cor_data)
```
```{r}
consumption_assets_normal_bayesmodel <-
  brm(formula = assetsconsumption_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        Lvill_eligible_ratio + Lroomsnumb + Ldurablesexpenditure +
        (1 | block) + (1 | vid),
     data = consumption_assets_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\consumption_assets_normal_bayes_v3")

# trace diagnostic plot
mcmc_trace(consumption_assets_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\consumption_assets_normal_race.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(consumption_assets_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\consumption_assets_normal_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(consumption_assets_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\consumption_assets_normal_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(consumption_assets_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\consumption_assets_normal_acf.png", plot = last_plot(), width = 12, height = 5)
```


```{r, include=FALSE, echo=FALSE}
# tidy_consumption_assets_normal_bayesmodel <- tidy(consumption_assets_normal_bayesmodel)
# #view(tidy_consumption_assets_normal_bayesmodel)
# write_csv(tidy_consumption_assets_normal_bayesmodel, "informed_prior_outcomes\\consumption_assets_normal_bayes.csv")
```

Model Summery
```{r}
summary(consumption_assets_normal_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(consumption_assets_normal_bayesmodel)
check_prior(consumption_assets_normal_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(consumption_assets_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_assetsconsumption_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "b_Ldietarydi_x_Lassetscon", "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\consumption_assets_normal_race.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(consumption_assets_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_assetsconsumption_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "b_Ldietarydi_x_Lassetscon", "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\consumption_assets_normal_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(consumption_assets_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_assetsconsumption_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "b_Ldietarydi_x_Lassetscon", "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\consumption_assets_normal_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(consumption_assets_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_assetsconsumption_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "b_Ldietarydi_x_Lassetscon", "b_Lproductiv_x_Lassetscon",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\consumption_assets_normal_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(consumption_assets_normal_bayesmodel, ndraws = 100)
pp_check(consumption_assets_normal_bayesmodel, ndraws = 10, type = 'error_scatter_avg', alpha = .1)
```


### **House Value** - Secondary Outcome

Load the **house value** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
dwelling_cost_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         selfcostdwell_asinh, # Outcome variable
         selfcostdwell_asinh_R1, # Baseline value of selfcostdwell_asinh, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, Lroomsnumb, Ldurablesexpenditure)  # controls
```


**house value**: This is the basic benchmarking model utilizing a prior normal distribution with mean = 0 and 6 standard deviations. This model had a number of errors and the posterior estimates are unreliable.

* Warning: There were 2023 divergent transitions after warmup. See https://mc-stan.org/misc/warnings.html#divergent-transitions-after-warmup to find out why this is a problem and how to eliminate them.
* Warning: There were 1977 transitions after warmup that exceeded the maximum treedepth. Increase max_treedepth above 10. See
https://mc-stan.org/misc/warnings.html#maximum-treedepth-exceeded
* Warning: There were 4 chains where the estimated Bayesian Fraction of Missing Information was low. See
https://mc-stan.org/misc/warnings.html#bfmi-low
* Warning: Examine the pairs() plot to diagnose sampling problems
* Warning: The largest R-hat is 4.46, indicating chains have not mixed. Running the chains for more iterations may help. See https://mc-stan.org/misc/warnings.html#r-hat
* Warning: Bulk Effective Samples Size (ESS) is too low, indicating posterior means and medians may be unreliable. Running the chains for more iterations may help. See https://mc-stan.org/misc/warnings.html#bulk-ess
* Warning: Tail Effective Samples Size (ESS) is too low, indicating posterior variances and tail quantiles may be unreliable. Running the chains for more iterations may help. See https://mc-stan.org/misc/warnings.html#tail-ess

```{r}
dwelling_cost_normal_bayesmodel <-
  brm(formula = selfcostdwell_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        selfcostdwell_asinh_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio + Lroomsnumb + Ldurablesexpenditure +
        (1 | block) + (1 | vid),
     data = dwelling_cost_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\dwelling_cost_normal_bayes")
```

```{r}
dwelling_cost_normal_bayesmodel <-
  brm(formula = selfcostdwell_asinh | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        (1 | block) + (1 | vid),
     data = dwelling_cost_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .99, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\dwelling_cost_normal_bayes_v2")
```

```{r}
cor_data <- dwelling_cost_data %>%
  select(selfcostdwell_asinh, cost_deviation, treat_any, treat_GK, selfcostdwell_asinh_R1,
         Lhh_wealth_asinh, Lvill_eligible_ratio, Lroomsnumb, Ldurablesexpenditure, block, vid)
cor_data <- dwelling_cost_data %>%
  select(selfcostdwell_asinh_R1, Lhh_wealth_asinh, Lvill_eligible_ratio, Lroomsnumb, Ldurablesexpenditure)

cor(cor_data)
```


```{r, include=FALSE, echo=FALSE}
# tidy_dwelling_cost_normal_bayesmodel <- tidy(dwelling_cost_normal_bayesmodel)
# #view(tidy_dwelling_cost_normal_bayesmodel)
# write_csv(tidy_dwelling_cost_normal_bayesmodel, "informed_prior_outcomes\\dwelling_cost_normal_bayes.csv")
```

Model Summery
```{r}
summary(dwelling_cost_normal_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(dwelling_cost_normal_bayesmodel)
check_prior(dwelling_cost_normal_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(dwelling_cost_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_selfcostdwell_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\dwelling_cost_normal_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(dwelling_cost_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_selfcostdwell_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\dwelling_cost_normal_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(dwelling_cost_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_selfcostdwell_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\dwelling_cost_normal_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(dwelling_cost_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_selfcostdwell_asinh_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", 
                    "b_Lroomsnumb", "b_Ldurablesexpenditure",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\dwelling_cost_normal_acf.png", plot = last_plot(), width = 12, height = 5)
```

```{r}
# trace diagnostic plot
mcmc_trace(dwelling_cost_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\dwelling_cost_normal_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(dwelling_cost_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\dwelling_cost_normal_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(dwelling_cost_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\dwelling_cost_normal_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(dwelling_cost_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
#ggsave("table_3_diagnostics\\dwelling_cost_normal_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(dwelling_cost_normal_bayesmodel, ndraws = 100)
pp_check(dwelling_cost_normal_bayesmodel, ndraws = 10, type = 'error_scatter_avg', alpha = .1)
```


### **house quality** - Secondary Outcome

Load the **house quality** model variables

```{r, include=FALSE}
# run linear model again using the bayesian "brms" package
housing_quality_data <- read_csv("gik_hh_main.csv") %>%
  select(hhid, round, vid, block, eligible, samp_wgt, cost_deviation,
         treat_any, treat_GK, # treatment dummies
         housing_quality, # Outcome variable
         housing_quality_R1, # Baseline value of housing_quality, present in both rounds
         Lhh_wealth_asinh, Lvill_eligible_ratio, Lroomsnumb)  # controls
```


**house quality**: This is the basic benchmarking model utilizing the default, uninformed priors

```{r}
housing_quality_normal_bayesmodel <-
  brm(formula = housing_quality | weights(samp_wgt) ~
        cost_deviation + treat_any + treat_GK +
        housing_quality_R1 + Lhh_wealth_asinh + Lvill_eligible_ratio + Lroomsnumb +
        (1 | block) + (1 | vid),
     data = housing_quality_data,
     family = gaussian("identity"),
     set_prior("normal(0,6)", class = "b"),
     seed = 1272022,
     warmup = 1000,
     iter = 2000,
     thin = 1,
     control = list(adapt_delta = .95, max_treedepth = 10),
     #backend = "cmdstanr",
     cores = 4, #overrides default 1 core
     #threads = 3,need to get cmdstanr package working here
     save_pars = save_pars(all = TRUE), # potentially allows for more post-processing functionality
     file = "informed_prior_outcomes\\housing_quality_normal_bayes")
```

```{r, include=FALSE, echo=FALSE}
# tidy_housing_quality_normal_bayesmodel <- tidy(housing_quality_normal_bayesmodel)
# #view(tidy_housing_quality_normal_bayesmodel)
# write_csv(tidy_housing_quality_normal_bayesmodel, "informed_prior_outcomes\\housing_quality_normal_bayes.csv")
```

Model Summery
```{r}
summary(housing_quality_normal_bayesmodel)
```

Prior summery - how informative are priors
```{r}
prior_summary(housing_quality_normal_bayesmodel)
check_prior(housing_quality_normal_bayesmodel)
```

Diagnostics
```{r}
# trace diagnostic plot
mcmc_trace(housing_quality_normal_bayesmodel, n_warmup = 0,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_housing_quality_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", "b_Lroomsnumb",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\housing_quality_normal_trace.png", plot = last_plot(), width = 12, height = 5)

#density diagnostic plots
mcmc_dens(housing_quality_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_housing_quality_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", "b_Lroomsnumb",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\housing_quality_normal_dens.png", plot = last_plot(), width = 12, height = 5)

mcmc_dens_overlay(housing_quality_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_housing_quality_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", "b_Lroomsnumb",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\housing_quality_normal_dens_overlay.png", plot = last_plot(), width = 12, height = 5)

#acf (auto-correlation) diagnostic plot
mcmc_acf(housing_quality_normal_bayesmodel,
           pars = c("b_Intercept", "b_cost_deviation", "b_treat_any", "b_treat_GK",
                    "b_housing_quality_R1", "b_Lhh_wealth_asinh", "b_Lvill_eligible_ratio", "b_Lroomsnumb",
                    "sd_block__Intercept", "sd_vid__Intercept", "sigma"))
ggsave("table_3_diagnostics\\housing_quality_normal_acf.png", plot = last_plot(), width = 12, height = 5)
```

posterior predictive checks
```{r}
pp_check(housing_quality_normal_bayesmodel, ndraws = 100)
pp_check(housing_quality_normal_bayesmodel, ndraws = 10, type = 'error_scatter_avg', alpha = .1)
```




